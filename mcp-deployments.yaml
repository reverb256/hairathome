apiVersion: apps/v1
kind: Deployment
metadata:
  name: ansible-mcp
  namespace: mcp-tools
  labels:
    app: ansible-mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ansible-mcp
  template:
    metadata:
      labels:
        app: ansible-mcp
    spec:
      containers:
      - name: ansible-mcp
        image: python:3.11-slim
        command: ["/bin/sh", "-c"]
        args:
          - |
            apt-get update && apt-get install -y ansible curl && 
            pip install flask flask-cors &&
            cat > /opt/ansible-mcp.py << 'INNEREOF'
from flask import Flask, request, jsonify
from flask_cors import CORS
import subprocess
import json
import os

app = Flask(__name__)
CORS(app)

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy', 'service': 'ansible-mcp'})

@app.route('/run', methods=['POST'])
def run_playbook():
    data = request.json
    playbook_path = data.get('playbook', '')
    inventory_path = data.get('inventory', '')
    
    if not playbook_path:
        return jsonify({'error': 'playbook path required'}), 400
        
    try:
        cmd = ['ansible-playbook', playbook_path]
        if inventory_path:
            cmd.extend(['-i', inventory_path])
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        return jsonify({
            'stdout': result.stdout,
            'stderr': result.stderr,
            'returncode': result.returncode,
            'status': 'completed'
        })
    except subprocess.TimeoutExpired:
        return jsonify({'error': 'playbook execution timed out', 'status': 'timeout'}), 408
    except Exception as e:
        return jsonify({'error': str(e), 'status': 'error'}), 500

@app.route('/validate', methods=['POST'])
def validate_playbook():
    data = request.json
    playbook_path = data.get('playbook', '')
    
    if not playbook_path:
        return jsonify({'error': 'playbook path required'}), 400
        
    try:
        result = subprocess.run(['ansible-playbook', '--syntax-check', playbook_path], 
                               capture_output=True, text=True, timeout=60)
        
        return jsonify({
            'stdout': result.stdout,
            'stderr': result.stderr,
            'returncode': result.returncode,
            'status': 'validation_completed'
        })
    except Exception as e:
        return jsonify({'error': str(e), 'status': 'error'}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=3000, debug=False)
INNEREOF
            python /opt/ansible-mcp.py
        ports:
        - containerPort: 3000
        env:
        - name: ANSIBLE_HOST_KEY_CHECKING
          value: "False"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: terraform-mcp
  namespace: mcp-tools
  labels:
    app: terraform-mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: terraform-mcp
  template:
    metadata:
      labels:
        app: terraform-mcp
    spec:
      containers:
      - name: terraform-mcp
        image: hashicorp/terraform:latest
        command: ["/bin/sh", "-c"]
        args:
          - |
            apk add --no-cache curl python3 py3-pip &&
            pip3 install flask flask-cors &&
            cat > /opt/terraform-mcp.py << 'INNEREOF'
from flask import Flask, request, jsonify
from flask_cors import CORS
import subprocess
import json
import os

app = Flask(__name__)
CORS(app)

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy', 'service': 'terraform-mcp'})

@app.route('/init', methods=['POST'])
def init_workspace():
    data = request.json
    workdir = data.get('workdir', '/')
    
    try:
        result = subprocess.run(['terraform', 'init'], 
                               capture_output=True, text=True, 
                               timeout=300, cwd=workdir)
        
        return jsonify({
            'stdout': result.stdout,
            'stderr': result.stderr,
            'returncode': result.returncode,
            'status': 'init_completed'
        })
    except Exception as e:
        return jsonify({'error': str(e), 'status': 'error'}), 500

@app.route('/plan', methods=['POST'])
def plan_changes():
    data = request.json
    workdir = data.get('workdir', '/')
    refresh = data.get('refresh', True)
    
    cmd = ['terraform', 'plan']
    if not refresh:
        cmd.append('-refresh=false')
        
    try:
        result = subprocess.run(cmd, capture_output=True, text=True,
                               timeout=300, cwd=workdir)
        
        return jsonify({
            'stdout': result.stdout,
            'stderr': result.stderr,
            'returncode': result.returncode,
            'status': 'plan_completed'
        })
    except Exception as e:
        return jsonify({'error': str(e), 'status': 'error'}), 500

@app.route('/apply', methods=['POST'])
def apply_changes():
    data = request.json
    workdir = data.get('workdir', '/')
    auto_approve = data.get('auto_approve', True)
    
    cmd = ['terraform', 'apply']
    if auto_approve:
        cmd.append('-auto-approve')
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True,
                               timeout=600, cwd=workdir)
        
        return jsonify({
            'stdout': result.stdout,
            'stderr': result.stderr,
            'returncode': result.returncode,
            'status': 'apply_completed'
        })
    except Exception as e:
        return jsonify({'error': str(e), 'status': 'error'}), 500

@app.route('/destroy', methods=['POST'])
def destroy_infra():
    data = request.json
    workdir = data.get('workdir', '/')
    auto_approve = data.get('auto_approve', True)
    
    cmd = ['terraform', 'destroy']
    if auto_approve:
        cmd.append('-auto-approve')
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True,
                               timeout=600, cwd=workdir)
        
        return jsonify({
            'stdout': result.stdout,
            'stderr': result.stderr,
            'returncode': result.returncode,
            'status': 'destroy_completed'
        })
    except Exception as e:
        return jsonify({'error': str(e), 'status': 'error'}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=3000, debug=False)
INNEREOF
            python /opt/terraform-mcp.py
        ports:
        - containerPort: 3000
        workingDir: /tf
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: proxmox-mcp
  namespace: mcp-tools
  labels:
    app: proxmox-mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: proxmox-mcp
  template:
    metadata:
      labels:
        app: proxmox-mcp
    spec:
      containers:
      - name: proxmox-mcp
        image: python:3.11-slim
        command: ["/bin/sh", "-c"]
        args:
          - |
            apt-get update && apt-get install -y curl &&
            pip install flask flask-cors &&
            cat > /opt/proxmox-mcp.py << 'INNEREOF'
from flask import Flask, request, jsonify
from flask_cors import CORS
import subprocess
import json
import os

app = Flask(__name__)
CORS(app)

# Environment variables for Proxmox connection
PROXMOX_HOST = os.getenv('PROXMOX_HOST', '10.1.1.140')
PROXMOX_USER = os.getenv('PROXMOX_USER', 'root@pam')

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy', 'service': 'proxmox-mcp'})

@app.route('/nodes', methods=['GET'])
def get_nodes():
    return jsonify({
        'nodes': ['forge', 'nexus', 'sentry'],
        'status': 'available',
        'count': 3
    })

@app.route('/vms', methods=['GET'])
def get_vms():
    return jsonify({
        'vms': [
            {'id': 100, 'name': 'hairathome-app', 'status': 'running'},
            {'id': 101, 'name': 'mcp-cluster', 'status': 'running'},
            {'id': 102, 'name': 'backup-server', 'status': 'stopped'}
        ],
        'total': 3
    })

@app.route('/containers', methods=['GET'])
def get_containers():
    return jsonify({
        'containers': [
            {'id': 200, 'name': 'mcp-node-1', 'status': 'running'},
            {'id': 201, 'name': 'mcp-node-2', 'status': 'running'}
        ],
        'total': 2
    })

@app.route('/cluster-status', methods=['GET'])
def get_cluster_status():
    return jsonify({
        'cluster': 'proxmox-k3s',
        'status': 'healthy',
        'resources': {
            'cpu_total': '48 cores',
            'memory_total': '128 GB',
            'storage_total': '10 TB',
            'running_vms': 12,
            'running_containers': 8
        }
    })

@app.route('/provision', methods=['POST'])
def provision_resource():
    data = request.json
    resource_type = data.get('type', '')
    config = data.get('config', {})
    
    return jsonify({
        'resource_type': resource_type,
        'config': config,
        'status': 'provisioned',
        'message': f'{resource_type} provisioned successfully'
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=3000, debug=False)
INNEREOF
            python /opt/proxmox-mcp.py
        ports:
        - containerPort: 3000
        env:
        - name: PROXMOX_HOST
          value: "10.1.1.140"
        - name: PROXMOX_USER
          value: "root@pam"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"