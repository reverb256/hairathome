apiVersion: v1
kind: Namespace
metadata:
  name: mcp-gateway
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-gateway-config
  namespace: mcp-gateway
data:
  # Environment variables for the MCP gateway
  NODE_ENV: "production"
  PORT: "3000"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-gateway
  namespace: mcp-gateway
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: mcp-gateway
  template:
    metadata:
      labels:
        app: mcp-gateway
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - mcp-gateway
              topologyKey: kubernetes.io/hostname
      containers:
      - name: mcp-gateway
        image: node:18-alpine
        command: ["/bin/sh", "-c"]
        args:
          - |
            # Install dependencies and create server
            npm init -y > /dev/null 2>&1
            npm install express cors http-proxy-middleware > /dev/null 2>&1
            
            # Create the server file
            cat > server.js << 'INNEREOF'
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const { spawn } = require('child_process');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3000;

// Enable CORS for all routes
app.use(cors());
app.use(express.json({ limit: '50mb' }));

// Simple validation helper
function validatePayload(payload, requiredFields = []) {
    for (const field of requiredFields) {
        if (!(field in payload)) {
            return { valid: false, error: `Missing required field: ${field}` };
        }
    }
    return { valid: true };
}

// Claude-flow MCP HTTP service
app.post('/mcp/claude-flow', async (req, res) => {
    console.log('Claude-flow MCP request:', req.body);
    
    // Validate input
    const validation = validatePayload(req.body, ['method']);
    if (!validation.valid) {
        return res.status(400).json({ error: validation.error });
    }

    try {
        const claudeProcess = spawn('npx', ['claude-flow@alpha', 'mcp', 'start'], {
            stdio: ['pipe', 'pipe', 'pipe'],
            env: { ...process.env, ...req.body.env }
        });

        let stdout = '';
        let stderr = '';
        let timeoutId;

        // Set timeout to prevent hanging processes
        timeoutId = setTimeout(() => {
            claudeProcess.kill();
        }, 300000); // 5 minute timeout

        claudeProcess.stdout.on('data', (data) => {
            stdout += data.toString();
        });

        claudeProcess.stderr.on('data', (data) => {
            stderr += data.toString();
        });

        claudeProcess.on('close', (code) => {
            clearTimeout(timeoutId);
            if (code === 0 || code === null) { // code can be null if process was killed by timeout
                res.json({ 
                    result: stdout || 'Claude-flow MCP executed',
                    status: code === 0 ? 'success' : 'timeout',
                    code: code
                });
            } else {
                res.status(500).json({ 
                    error: stderr || `Claude-flow MCP failed with code ${code}`,
                    status: 'error',
                    code: code
                });
            }
        });

        // Send initial input to the process if needed
        if (req.body.input) {
            claudeProcess.stdin.write(JSON.stringify(req.body.input) + '\n');
        }
        claudeProcess.stdin.end();
    } catch (error) {
        res.status(500).json({ error: error.message, status: 'internal_error' });
    }
});

// Flow-nexus MCP HTTP service
app.post('/mcp/flow-nexus', async (req, res) => {
    console.log('Flow-nexus MCP request:', req.body);
    
    // Validate input
    const validation = validatePayload(req.body, ['method']);
    if (!validation.valid) {
        return res.status(400).json({ error: validation.error });
    }

    try {
        const flowProcess = spawn('npx', ['flow-nexus@latest', 'mcp', 'start'], {
            stdio: ['pipe', 'pipe', 'pipe'],
            env: { ...process.env, ...req.body.env }
        });

        let stdout = '';
        let stderr = '';
        let timeoutId;

        // Set timeout to prevent hanging processes
        timeoutId = setTimeout(() => {
            flowProcess.kill();
        }, 300000); // 5 minute timeout

        flowProcess.stdout.on('data', (data) => {
            stdout += data.toString();
        });

        flowProcess.stderr.on('data', (data) => {
            stderr += data.toString();
        });

        flowProcess.on('close', (code) => {
            clearTimeout(timeoutId);
            if (code === 0 || code === null) {
                res.json({ 
                    result: stdout || 'Flow-nexus MCP executed',
                    status: code === 0 ? 'success' : 'timeout',
                    code: code
                });
            } else {
                res.status(500).json({ 
                    error: stderr || `Flow-nexus MCP failed with code ${code}`,
                    status: 'error',
                    code: code
                });
            }
        });

        // Send initial input to the process if needed
        if (req.body.input) {
            flowProcess.stdin.write(JSON.stringify(req.body.input) + '\n');
        }
        flowProcess.stdin.end();
    } catch (error) {
        res.status(500).json({ error: error.message, status: 'internal_error' });
    }
});

// Vibe-LLM proxy service
app.use('/api/vibe-llm', createProxyMiddleware({
    target: 'http://localhost:8000',
    changeOrigin: true,
    pathRewrite: {
        '^/api/vibe-llm': '', // Remove the /api/vibe-llm prefix when forwarding
    },
    onProxyReq: (proxyReq, req, res) => {
        console.log('Proxying request to Vibe-LLM:', req.url);
    },
    onProxyRes: (proxyRes, req, res) => {
        console.log('Vibe-LLM response status:', proxyRes.statusCode);
    }
}));

// Kubernetes API proxy (for the k8s MCP)
app.use('/api/kubernetes', createProxyMiddleware({
    target: 'https://kubernetes.default.svc.cluster.local',
    secure: false, // Disable SSL verification for internal k8s API
    changeOrigin: true,
    headers: {
        'Authorization': `Bearer ${process.env.KUBERNETES_TOKEN || ''}`
    },
    pathRewrite: {
        '^/api/kubernetes': '', // Remove the prefix
    }
}));

// Terraform HTTP service
app.post('/mcp/terraform', async (req, res) => {
    console.log('Terraform MCP request:', req.body);
    
    try {
        // Verify terraform is available
        const fs = require('fs');
        if (!fs.existsSync('/usr/bin/terraform')) {
            return res.status(500).json({ error: 'Terraform not found', status: 'not_found' });
        }

        const command = req.body.command || 'plan';
        const workDir = req.body.workDir || '/tmp';
        const tfProcess = spawn('terraform', [command], {
            cwd: workDir,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        let stdout = '';
        let stderr = '';

        tfProcess.stdout.on('data', (data) => {
            stdout += data.toString();
        });

        tfProcess.stderr.on('data', (data) => {
            stderr += data.toString();
        });

        tfProcess.on('close', (code) => {
            if (code === 0) {
                res.json({ 
                    result: stdout,
                    status: 'success',
                    code: code
                });
            } else {
                res.status(500).json({ 
                    error: stderr,
                    status: 'error',
                    code: code
                });
            }
        });

        tfProcess.stdin.end();
    } catch (error) {
        res.status(500).json({ error: error.message, status: 'internal_error' });
    }
});

// Proxmox HTTP service
app.post('/mcp/proxmox', async (req, res) => {
    console.log('Proxmox MCP request:', req.body);
    
    try {
        // This would integrate with Proxmox API
        // For now, we return a mock response, in real implementation would call Proxmox API
        const response = {
            result: 'Proxmox operation initiated',
            status: 'accepted',
            request: req.body
        };
        res.json(response);
    } catch (error) {
        res.status(500).json({ error: error.message, status: 'internal_error' });
    }
});

// Filesystem HTTP service (proxy to the k8s filesystem-mcp)
app.use('/mcp/filesystem', createProxyMiddleware({
    target: 'http://filesystem-mcp-service.mcp-tools.svc.cluster.local:3000',
    changeOrigin: true,
    onProxyReq: (proxyReq, req, res) => {
        console.log('Proxying filesystem request:', req.url);
    }
}));

// Playwright HTTP service (proxy to the k8s playwright-mcp)
app.use('/mcp/playwright', createProxyMiddleware({
    target: 'http://playwright-mcp-service.mcp-tools.svc.cluster.local:3000',
    changeOrigin: true,
    onProxyReq: (proxyReq, req, res) => {
        console.log('Proxying playwright request:', req.url);
    }
}));

// Health check
app.get('/health', (req, res) => {
    res.json({ 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        services: {
            'claude-flow': 'ready',
            'flow-nexus': 'ready', 
            'vibe-llm': 'ready',
            'kubernetes': 'ready',
            'terraform': 'ready',
            'proxmox': 'ready',
            'filesystem': 'ready',
            'playwright': 'ready'
        }
    });
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(`MCP Gateway server running on port ${PORT}`);
    console.log('Available endpoints:');
    console.log('  POST /mcp/claude-flow   - Claude-flow MCP service');
    console.log('  POST /mcp/flow-nexus   - Flow-nexus MCP service');
    console.log('  POST /mcp/terraform    - Terraform MCP service');
    console.log('  POST /mcp/proxmox      - Proxmox MCP service');
    console.log('  GET  /health           - Health check');
    console.log('  All other services are proxied to their respective services');
});
INNEREOF
            
            # Run the server
            node server.js
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: KUBERNETES_TOKEN
          valueFrom:
            secretKeyRef:
              name: default-token  # Use the default service account token
              key: token
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: mcp-gateway
  namespace: mcp-gateway
spec:
  selector:
    app: mcp-gateway
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: ClusterIP